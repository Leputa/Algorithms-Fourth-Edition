import edu.princeton.cs.algs4.StdOut;
import edu.princeton.cs.algs4.In;
import edu.princeton.cs.algs4.Stack;

public class Board {
	private int N;
	private int[][] boards;
	private int num_hamming=0;
	private int num_manhattan=0;
	private int blank_i;
	private int blank_j;
	
	// construct a board from an n-by-n array of blocks
    // (where blocks[i][j] = block in row i, column j)
    public Board(int[][] blocks){ 
    	if(blocks==null)
    		throw new java.lang.NullPointerException(" null argument");
    	N=blocks.length;
    	this.boards=new int[N+1][N+1];
    	for(int i=1;i<=N;i++)
    		for(int j=1;j<=N;j++)
    			this.boards[i][j]=blocks[i-1][j-1];
    }   
    
    public int dimension(){                 // board dimension n
    	return N;
    }
    
    public int hamming(){                   // number of blocks out of place
    	for(int i=1;i<=N;i++){
    		for(int j=1;j<=N;j++){
    			if((boards[i][j]!=(i-1)*N+j)&&boards[i][j]!=0)
    				num_hamming++;
    		}
    	}
    	return num_hamming;
    }
    
    public int manhattan(){  // sum of Manhattan distances between blocks and goal
    	for(int i=1;i<=N;i++)
    		for(int j=1;j<=N;j++)
    			if(boards[i][j]!=(i-1)*N+j&&boards[i][j]!=0){
    				int goali=(int)Math.ceil(boards[i][j]/N);
    				int goalj=boards[i][j]%N;
    				if(0==goalj)
    					goalj=N;
    				int distance=Math.abs(goali-i)+Math.abs(goalj-j);
    				num_manhattan+=distance;
    			}
    	return num_hamming;
    }
    
    public boolean isGoal(){                // is this board the goal board?
    	return this.hamming()==0;
    }
    
    public Board twin()                    // a board that is obtained by exchanging any pair of blocks
    {
    	int [][]twinboards=new int [N+1][N+1];
    	for(int i=1;i<=N;i++)
    		for(int j=1;j<=N;j++)
    			twinboards[i][j]=boards[i][j];
    	if(boards[1][1]!=0&&boards[1][2]!=0){
    		int tmp=twinboards[1][1];
    		twinboards[1][1]=twinboards[1][2];
    		twinboards[1][2]=tmp;
    	}
    	else{
    		int tmp=twinboards[2][1];
    		twinboards[2][1]=twinboards[2][2];
    		twinboards[2][2]=tmp;
    	}
    	return new Board(twinboards);
    }
    
    public boolean equals(Object y){        // does this board equal y?
    	if(y==this)
    		return true;
    	if(y==null)
    		return false;
    	if(y.getClass()!=this.getClass())
    		return false;
    	Board yy=(Board)y;
    	if(this.N!=yy.N)
    		return false;
    	for(int i=1;i<=N;i++)
    		for(int j=1;j<=N;j++)
    			if(boards[i][i]!=yy.boards[i][j])
    				return false;
    	return true;
    }
    
    public Iterable<Board> neighbors(){     // all neighboring boards
    	int [][]copy=new int[N+1][N+1];
    	for(int i=1;i<=N;i++)
    		for(int j=1;j<=N;j++){
    			copy[i][j]=boards[i][j];
    			if(boards[i][j]==0){
    				blank_i=i;
    				blank_j=j;
    			}
    		}
    	Stack<Board> neighbors=new Stack<Board>();
    	if(blank_i!=1){
    		swap(copy, blank_i, blank_j, blank_i-1, blank_j);
    		neighbors.push(new Board(copy));
    		swap(copy, blank_i, blank_j, blank_i-1, blank_j);
    	}
    	if(blank_i!=N){
    		swap(copy, blank_i, blank_j, blank_i+1, blank_j);
    		neighbors.push(new Board(copy));
    		swap(copy, blank_i, blank_j, blank_i+1, blank_j);
    	}
    	if(blank_j!=1){
    		swap(copy, blank_i, blank_j, blank_i, blank_j-1);
    		neighbors.push(new Board(copy));
    		swap(copy, blank_i, blank_j, blank_i, blank_j-1);
    	}
    	if(blank_j!=N){
    		swap(copy, blank_i, blank_j, blank_i, blank_j+1);
    		neighbors.push(new Board(copy));
    		swap(copy, blank_i, blank_j, blank_i, blank_j+1);
    	}
    	return neighbors;
    }
    
    private void swap(int[][]array,int i,int j,int a,int b){
    	int tmp=array[i][j];
    	array[i][j]=array[a][b];
    	array[a][b]=tmp;
    }
    
    public String toString(){               // string representation of this board (in the output format specified below)
    	StringBuilder board=new StringBuilder();
    	board.append(N+"\n");
    	for(int i=1;i<=N;i++){
    		for(int j=1;j<=N;j++)
    			board.append(String.format("%2d", boards[i][j]));
    		board.append("\n");
    	}
    	return board.toString();
    }
    
    public static void main(String[] args) {  // unit tests (not graded)
    	 // create initial board from file  
        In in = new In("./8puzzle/puzzle2x2-01.txt");  
        int N = in.readInt();  
        int[][] blocks = new int[N][N];  
        for (int i = 0; i < N; i++)  
            for (int j = 0; j < N; j++)  
                blocks[i][j] = in.readInt();  
        Board initial = new Board(blocks);  
        StdOut.println(initial);  
        StdOut.println(initial.hamming());  
    }  
}